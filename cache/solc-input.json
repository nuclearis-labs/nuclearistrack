{
  "language": "Solidity",
  "sources": {
    "src/contracts/NuclearPoE.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.5.2;\n\nimport './Process.sol';\nimport './Ownable.sol';\n\n/// @title Main Contract for Nuclearis Track\n/// @author Sebastian A. Martinez\n/// @notice This contract is the main entrypoint for the Nuclearistrack Platform\ncontract NuclearPoE is Ownable {\n    enum State {Null, Created, Closed}\n    enum Type {Admin, Client, Supplier}\n\n    struct Project {\n        State status;\n        address clientAddress;\n        string title;\n        string purchaseOrder;\n        address[] processContracts;\n    }\n    struct User {\n        State status;\n        Type userType;\n        string name;\n    }\n\n    address[] public processContractsArray;\n    address[] private _users;\n    uint256[] public projectsArray;\n\n    mapping(address => uint256[]) public projectsByAddress;\n    mapping(address => address[]) public processesByAddress;\n    mapping(address => User) private _user;\n    mapping(uint256 => Project) private _project;\n\n    event CreateProject(uint256 id);\n    event CreateUser(address userAddress);\n    event CreateProcess(address processContractAddress);\n    event AssignProcess(uint256 project, address processContractAddress);\n    event AssignClient(uint256 project, address clientAddress);\n    event ToggleProjectStatus(uint256 id, State newState);\n    event ToggleUserStatus(address userAddress, State newState);\n\n    modifier onlyUser() {\n        require(\n            _user[msg.sender].status == State.Created,\n            'Sender is not whitelisted'\n        );\n        _;\n    }\n\n    constructor(string memory _name) public {\n        // Creates the admin _user, similar to an owner\n        _user[msg.sender] = User(State.Created, Type.Admin, _name);\n        _users.push(msg.sender);\n    }\n\n    /// @notice Creates a new project\n    /// @param _id Id of a new project\n    /// @param _title Title of new project\n    /// @param _purchaseOrder Purchase Order Id of project\n    function createProject(\n        uint256 _id,\n        string calldata _title,\n        string calldata _purchaseOrder\n    ) external onlyOwner {\n        require(\n            _project[_id].status == State.Null,\n            'Project already created or closed'\n        );\n\n        address[] memory processContracts = new address[](0);\n        _project[_id] = Project(\n            State.Created,\n            address(0),\n            _title,\n            _purchaseOrder,\n            processContracts\n        );\n        projectsArray.push(_id);\n\n        emit CreateProject(_id);\n    }\n\n    function assignClient(uint256 _id, address _client) external onlyOwner {\n        projectsByAddress[_client].push(_id);\n        _project[_id].clientAddress = _client;\n\n        emit AssignClient(_id, _client);\n    }\n\n    /// @notice Creates a new _user\n    /// @param _type Type of _user\n    /// @param _address Address of _user\n    /// @param _name Name of _user\n    function createUser(\n        Type _type,\n        address _address,\n        string calldata _name\n    ) external onlyOwner {\n        _user[_address] = User(State.Created, _type, _name);\n        _users.push(_address);\n\n        emit CreateUser(_address);\n    }\n\n    /// @notice Toggles a _user status\n    /// @param _address Address of _user to be toggled\n    function toggleUserStatus(address _address) external onlyOwner {\n        require(_user[_address].status != State.Null, 'User does not exist');\n\n        if (_user[_address].status == State.Created)\n            _user[_address].status = State.Closed;\n        else _user[_address].status = State.Created;\n\n        emit ToggleUserStatus(_address, _user[_address].status);\n    }\n\n    /// @notice Creates a new process and deploys contract\n    /// @param _supplier Supplier Address\n    /// @param _processName Name of supplier of process\n    /// @param _processName Name of supplier of process\n    function createProcess(address _supplier, string calldata _processName)\n        external\n        onlyOwner\n    {\n        address processContractAddress = address(\n            new Process(_supplier, _processName, owner())\n        );\n        processesByAddress[_supplier].push(processContractAddress);\n        processContractsArray.push(processContractAddress);\n\n        emit CreateProcess(processContractAddress);\n    }\n\n    /// @notice Adds a process address to a specific project\n    /// @param _id The id of a project\n    /// @param _processContract The address of a process contract\n    function addProcessToProject(uint256 _id, address _processContract)\n        external\n        onlyOwner\n    {\n        require(\n            _project[_id].status == State.Created,\n            'Project does not exist or is closed'\n        );\n\n        _project[_id].processContracts.push(_processContract);\n\n        emit AssignProcess(_id, _processContract);\n    }\n\n    /// @notice Toggles a project status\n    /// @param _id The id of a project\n    function toggleProjectStatus(uint256 _id) external onlyOwner {\n        require(_project[_id].status != State.Null, 'Project does not exist');\n\n        if (_project[_id].status == State.Created)\n            _project[_id].status = State.Closed;\n        else _project[_id].status = State.Created;\n\n        emit ToggleProjectStatus(_id, _project[_id].status);\n    }\n\n    /// @notice Returns specific information about one _user\n    /// @param _address User Address\n    /// @return Type User Type (supplier or client)\n    /// @return string Name of _user\n    function getUser(address _address)\n        external\n        view\n        onlyUser\n        returns (\n            State,\n            Type,\n            string memory,\n            address\n        )\n    {\n        return (\n            _user[_address].status,\n            _user[_address].userType,\n            _user[_address].name,\n            _address\n        );\n    }\n\n    /// @notice Returns all saved _users\n    /// @return address[] Returns array of all created _users\n    function getAllUsers() external view onlyOwner returns (address[] memory) {\n        return _users;\n    }\n\n    /// @notice Returns all processes\n    /// @return address[] Array of all process contracts\n    function getProcessContractsByProject(uint256 _id)\n        external\n        view\n        returns (address[] memory)\n    {\n        require(\n            _project[_id].clientAddress == msg.sender || msg.sender == owner(),\n            'Project and Client do not match'\n        );\n        return _project[_id].processContracts;\n    }\n\n    /// @notice Returns processes assigned to a supplier\n    /// @return address[] Array of process contract addresses specified to a supplier\n    function getProcessesByAddress() external view returns (address[] memory) {\n        if (msg.sender == owner()) {\n            return processContractsArray;\n        } else {\n            return (processesByAddress[msg.sender]);\n        }\n    }\n\n    /// @notice Returns projects assigned to a client\n    /// @return uint256[] Array of projects ids specified to a client\n    function getProjectsByAddress() external view returns (uint256[] memory) {\n        if (msg.sender == owner()) {\n            return projectsArray;\n        } else {\n            return (projectsByAddress[msg.sender]);\n        }\n    }\n\n    /// @notice Returns details of a project id\n    /// @param _id The id of the project\n    /// @return status Current State of project\n    /// @return address Client assigned to project\n    /// @return string Title of project\n    /// @return string Purchase order of project\n    /// @return address[] Array of process contract addresses assigned to project\n    function getProjectDetails(uint256 _id)\n        external\n        view\n        returns (\n            State,\n            uint256,\n            address,\n            string memory,\n            string memory,\n            address[] memory\n        )\n    {\n        require(\n            msg.sender == _project[_id].clientAddress || msg.sender == owner(),\n            'User has to be assigned client or owner'\n        );\n        return (\n            _project[_id].status,\n            _id,\n            _project[_id].clientAddress,\n            _project[_id].title,\n            _project[_id].purchaseOrder,\n            _project[_id].processContracts\n        );\n    }\n}\n"
    },
    "src/contracts/Process.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.5.2;\n\nimport './NuclearPoE.sol';\n\n/// @title Process Contract\n/// @author Sebastian A. Martinez\n/// @notice This contract is responsible for each process and its corresponding documents\ncontract Process {\n    string private _processName;\n    address private _supplierAddress;\n    address private _owner;\n\n    struct Document {\n        string name;\n        string latitude;\n        string longitude;\n        uint256 mineTime;\n        string comment;\n    }\n\n    bytes32[] public allDocuments;\n    mapping(bytes32 => Document) private _document;\n\n    event AddDocument(bytes32 hash);\n\n    modifier onlySupplier() {\n        require(\n            msg.sender == _supplierAddress,\n            'Sender is not supplier of project'\n        );\n        _;\n    }\n\n    constructor(\n        address _supplier,\n        string memory _name,\n        address _ownerAddress\n    ) public {\n        _supplierAddress = _supplier;\n        _processName = _name;\n        _owner = _ownerAddress;\n    }\n\n    /// @notice Creates a new document\n    /// @param _name Name of new document\n    /// @param _hash Hash of document\n    /// @param _latitude Latitude\n    /// @param _longitude Longitude\n    /// @param _comment Comment\n    function addDocument(\n        string calldata _name,\n        bytes32 _hash,\n        string calldata _latitude,\n        string calldata _longitude,\n        string calldata _comment\n    ) external onlySupplier() {\n        require(_document[_hash].mineTime == 0, 'Document already created');\n\n        _document[_hash] = Document(\n            _name,\n            _latitude,\n            _longitude,\n            now, //solhint-disable-line not-rely-on-time\n            _comment\n        );\n        allDocuments.push(_hash);\n\n        emit AddDocument(_hash);\n    }\n\n    /// @notice Gets document metadata by hash\n    /// @param _hash Hash of document\n    /// @return string Name of document\n    /// @return string Latitude\n    /// @return string Longitude\n    /// @return uint256 mineTime Moment the transaction got mined\n    /// @return string Comment\n    function getDocument(bytes32 _hash)\n        external\n        view\n        returns (\n            string memory,\n            bytes32,\n            string memory,\n            string memory,\n            uint256,\n            string memory\n        )\n    {\n        require(_document[_hash].mineTime != 0, 'Document does not exist');\n        return (\n            _document[_hash].name,\n            _hash,\n            _document[_hash].latitude,\n            _document[_hash].longitude,\n            _document[_hash].mineTime,\n            _document[_hash].comment\n        );\n    }\n\n    /// @notice Gets details about this contract\n    /// @return address Address of supplier of this process\n    /// @return string Name of process\n    /// @return bytes32[] Array of all document hashes in this process\n    /// @return address Address of contract\n    function getDetails()\n        external\n        view\n        returns (\n            address,\n            string memory,\n            bytes32[] memory,\n            address\n        )\n    {\n        return (_supplierAddress, _processName, allDocuments, address(this));\n    }\n}\n"
    },
    "src/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.2;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, 'Ownable: caller is not the owner');\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(\n            newOwner != address(0),\n            'Ownable: new owner is the zero address'\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}